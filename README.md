Spaghetti
=========

Spaghetti helps you in creating large-scale modular JavaScript applications with modules written in different compile-to-JS languages. It allows a module's code to call another module in a type-safe way regardless of the language either module is written in.

[![Build Status](https://travis-ci.org/prezi/spaghetti.svg)](https://travis-ci.org/prezi/spaghetti)

Currently Spaghetti can only be used from Gradle. We plan to support other build systems and a stand-alone command-line tool in the future.

Gradle 2.0 required. With earlier versions you will get an error that `org.gradle.runtime.base.BinaryContainer` is missing.

## How does it work?

When you create a Spaghetti module, you start by defining the module's API in the Spaghetti [IDL](http://en.wikipedia.org/wiki/Interface_description_language). Something like this:

```
module com.example.module as MyModule

/**
 * A tool to greet guests.
 */
interface Greeter {

	/**
	 * Greets a guest and returns the greeting.
	 */
	string sayHello(string guest)
}

/**
 * Creates a Greeter.
 */
Greeter createGreeter()
```

From this definition Spaghetti can generate interfaces for its supported platforms (currently Haxe and TypeScript are available):

```haxe
/* Generated by Spaghetti */
package com.example.module;

interface MyModule {
	/**
	 * Creates a Greeter.
	 */
	function createGreeter():Greeter;
}
```

```haxe
/* Generated by Spaghetti */
package com.example.module;

interface Greeter {
	/**
	 * Greets a guest and returns the greeting.
	 */
	function sayHello(guest:String):String;
}
```

You then implement the generated interfaces, and compile your code into a JavaScript file. In Haxe you would write the following:

```haxe
package com.example.module;

// Spaghetti looks for a class called "<ModuleName>" that implements the interface called "I<ModuleName>"
class MyModule implements IMyModule {
	public function createGreeter():Greeter {
		return new DefaultGreeter();
	}
}

class DefaultGreeter implements Greeter {
	public function sayHello(guest:String):String {
		return 'Hello ${guest}!';
	}
}
```

Once you have your module compiled into a single JS file, Spaghetti will wrap it into a [RequireJs](http://requirejs.org/)-compatible module, and bundle it into a ZIP file together with the module definition (the IDL you wrote above). It is also possible to include resources (images, CSS etc.) in a module bundle.

When someone wants to use your module, they only need to provide Spaghetti with the bundle ZIP you've created. Spaghetti can then generate proxy classes that will allow calling your module in a type-safe way. To continue with the example, you could call your Haxe module from TypeScript:

```typescript
var greeter = com.example.module.MyModule.createGreeter();
console.log(greeter.sayHello("World"));
```

Check out the working example under [spaghetti-gradle-example](spaghetti-gradle-example).

## Build system support

### Gradle

Spaghetti comes with a Gradle plugin that makes it very easy to integrate Spaghetti into your workflow.

Read more about in the [plugin's readme](gradle-spaghetti-plugin/README.md).

### Other systems

A command-line tool and Maven support is planned, but no clear deadline is decided right now.
